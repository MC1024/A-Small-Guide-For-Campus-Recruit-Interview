
* [一般](#%E4%B8%80%E8%88%AC)
  * [OSI与TCP/IP各层的结构与功能，都有哪些协议?](#osi%E4%B8%8Etcpip%E5%90%84%E5%B1%82%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE)
    * [应用层](#%E5%BA%94%E7%94%A8%E5%B1%82)
    * [表示层](#%E8%A1%A8%E7%A4%BA%E5%B1%82)
    * [会话层](#%E4%BC%9A%E8%AF%9D%E5%B1%82)
    * [传输层](#%E4%BC%A0%E8%BE%93%E5%B1%82)
    * [网络层](#%E7%BD%91%E7%BB%9C%E5%B1%82)
    * [数据链路层](#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82)
    * [物理层](#%E7%89%A9%E7%90%86%E5%B1%82)
  * [子网掩码](#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81)
  * [在浏览器中输入url地址 \-&gt; 显示主页的过程](#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%9C%B0%E5%9D%80---%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B)
* [DNS](#dns)
  * [域名](#%E5%9F%9F%E5%90%8D)
  * [组成与原理](#%E7%BB%84%E6%88%90%E4%B8%8E%E5%8E%9F%E7%90%86)
    * [本地DNS](#%E6%9C%AC%E5%9C%B0dns)
    * [过程](#%E8%BF%87%E7%A8%8B)
  * [记录类型](#%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B)
  * [DNS劫持](#dns%E5%8A%AB%E6%8C%81)
  * [DNS污染（中间人攻击）](#dns%E6%B1%A1%E6%9F%93%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB)
* [TCP协议](#tcp%E5%8D%8F%E8%AE%AE)
  * [TCP 三次握手和四次挥手](#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
    * [三次握手](#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
    * [为什么要三次握手](#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
    * [为什么要传回 SYN](#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%A0%E5%9B%9E-syn)
    * [传了 SYN，为啥还要传 ACK](#%E4%BC%A0%E4%BA%86-syn%E4%B8%BA%E5%95%A5%E8%BF%98%E8%A6%81%E4%BC%A0-ack)
    * [为什么四次挥手](#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
  * [TCP与UDP协议的区别](#tcp%E4%B8%8Eudp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB)
  * [TCP 协议如何保证可靠传输](#tcp-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93)
    * [ARQ协议](#arq%E5%8D%8F%E8%AE%AE)
      * [停止等待ARQ协议](#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85arq%E5%8D%8F%E8%AE%AE)
      * [连续ARQ协议](#%E8%BF%9E%E7%BB%ADarq%E5%8D%8F%E8%AE%AE)
    * [滑动窗口和流量控制](#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6)
    * [拥塞控制](#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
  * [TIME\_WAIT状态的作用](#time_wait%E7%8A%B6%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8)
  * [TIME\_WAIT的问题](#time_wait%E7%9A%84%E9%97%AE%E9%A2%98)
    * [客户端](#%E5%AE%A2%E6%88%B7%E7%AB%AF)
    * [服务端](#%E6%9C%8D%E5%8A%A1%E7%AB%AF)
  * [tcp建立连接的两端, 有一端断开连接另一端能知道吗](#tcp%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%B8%A4%E7%AB%AF-%E6%9C%89%E4%B8%80%E7%AB%AF%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%8F%A6%E4%B8%80%E7%AB%AF%E8%83%BD%E7%9F%A5%E9%81%93%E5%90%97)
* [HTTP协议](#http%E5%8D%8F%E8%AE%AE)
  * [HTTP Request](#http-request)
  * [HTTP Response](#http-response)
  * [HTTP状态码](#http%E7%8A%B6%E6%80%81%E7%A0%81)
  * [HTTP请求有哪些方式](#http%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F)
  * [GET/POST区别](#getpost%E5%8C%BA%E5%88%AB)
  * [各种协议与HTTP协议之间的关系](#%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8Ehttp%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB)
  * [HTTP长连接，短连接](#http%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9F%AD%E8%BF%9E%E6%8E%A5)
  * [HTTP是不保存状态的协议，如何保存用户状态?](#http%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81)
  * [Cookie的作用是什么?和Session有什么区别？](#cookie%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E5%92%8Csession%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB)
  * [如何使用Session进行身份验证](#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8session%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81)
  * [如果没有Cookie的话Session还能用吗？](#%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89cookie%E7%9A%84%E8%AF%9Dsession%E8%BF%98%E8%83%BD%E7%94%A8%E5%90%97)
  * [什么是 Token?什么是 JWT?如何基于Token进行身份验证？](#%E4%BB%80%E4%B9%88%E6%98%AF-token%E4%BB%80%E4%B9%88%E6%98%AF-jwt%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Etoken%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81)
  * [为什么Cookie 无法防止CSRF攻击，而token可以？](#%E4%B8%BA%E4%BB%80%E4%B9%88cookie-%E6%97%A0%E6%B3%95%E9%98%B2%E6%AD%A2csrf%E6%94%BB%E5%87%BB%E8%80%8Ctoken%E5%8F%AF%E4%BB%A5)
  * [HTTP 1\.0和HTTP 1\.1的主要区别是什么?](#http-10%E5%92%8Chttp-11%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)
  * [HTTP2\.0的改进](#http20%E7%9A%84%E6%94%B9%E8%BF%9B)
  * [URI和URL的区别是什么?](#uri%E5%92%8Curl%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)
  * [HTTP 和 HTTPS 的区别？](#http-%E5%92%8C-https-%E7%9A%84%E5%8C%BA%E5%88%AB)
  * [HTTPS中的TLS](#https%E4%B8%AD%E7%9A%84tls)
    * [SSL 与 TLS](#ssl-%E4%B8%8E-tls)
    * [TLS工作流程](#tls%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B)
    * [TLS使用的密码技术](#tls%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF)
  * [断点续传](#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0)
  * [HTTP Cache](#http-cache)




# 一般

## OSI与TCP/IP各层的结构与功能，都有哪些协议?

### 应用层

**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS**，支持万维网应用的 **HTTP协议**，支持电子邮件的 **SMTP协议**等等。我们把应用层交互的数据单元称为报文。

**域名系统**

> 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）

**HTTP协议**

> 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）

### 表示层

信息的语法语义以及它们的关联，比如加密解密、转换翻译、压缩解压缩等。

### 会话层

不同机器上的用户之间建立与管理会话。

### 传输层

**传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。

**传输层主要使用以下两种协议:**

1. **传输控制协议 TCP**（Transmission Control Protocol）--提供**面向连接**的，**可靠的**数据传输服务。
2. **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

### 网络层

**在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。** 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 **IP 协议**，因此分组也叫 **IP 数据报** ，简称 **数据报**。

这里要注意：**不要把传输层的“UDP用户数据报”和网络层的“IP数据报”弄混**。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。

这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.

互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做**网际层**或**IP层**。

### 数据链路层

**数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。** 在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。

### 物理层

在物理层上所传送的数据单位是比特。 **物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。** 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。



## 子网掩码

子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用。

子网掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。

作用：就是将某个IP地址划分成网络地址和主机地址两部分，帮助设备计算网络地址，或用于子网划分及合并。



## 在浏览器中输入url地址 -> 显示主页的过程

1. DNS解析

   浏览器查找域名的IP地址（DNS查找过程：浏览器缓存、路由器缓存、DNS缓存）

2. TCP连接

   三次握手

3. 发送HTTP请求

   浏览器向web服务器发送一个HTTP请求（cookies会一并发送）

4. 服务器处理请求并返回HTTP报文

   处理收到的请求、参数、cookies，生成HTML响应并返回

5. 浏览器解析渲染页面

6. 连接结束

   四次挥手



# DNS

域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。

## 域名

域名按照从右到左的顺序来划分优先等级，最右边的是最高级的根域，根域就是所谓的”.”

其实我们的域名www.baidu.com在配置当中应该是www.baidu.com.（最后有一个点），一般我们在浏览器里输入时会省略后面的点。接下来就是顶级域又称一级域，一级域之后还有二级三级域。如何区分当前域名是几级域，可以参考域名中有几个点来判断（除了根域外），比如baidu.com就是个一级域，而www.baidu.com就是个二级域（它是在baidu.com这个域里面有一个叫做www的主机）

每一层域都会有一堆域名（DNS）服务器，DNS服务器是能提供域名解析的服务器，记录类型可以是A（address）记录，NS（name server）记录，MX（mail），CNAME等



## 组成与原理

DNS服务器一般分三种，根DNS服务器，顶级DNS服务器，权威DNS服务器

### 本地DNS

本地DNS一般是指你电脑上网时IPv4或者IPv6设置中填写的那个DNS。这个有可能是手工指定的或者是自动分配的。

如果你的电脑是直连运营商（ISP）网络，一般默认设置情况下DNS为ISP的服务器地址。

如果你的电脑和ISP之间还加了无线或者有线路由（一般的路由器本身还会内置DNS转发器），它的作用是将发往它所有的DNS请求转发到上层DNS，但最终会转发到ISP的DNS。

如果手动修改了DNS，比如改成8.8.8.8这样的公用DNS服务器，那么指的就是这个服务器。

本地DNS不是权威服务器，**相当于一个代理的DNS解析服务器**，他会帮你迭代权威服务器返回的回答，然后把最终查到的IP返回给你。

### 过程

1. 现在我有一台电脑，在浏览器中输入[www.baidu.com](http://www.baidu.com/)域名，浏览器会从**浏览器的DNS缓存**中检查是否有这个网址的映射关系，如果有，就返回IP，完成域名解析
2. 如果没有，操作系统会先检查自己**本地的hosts文件**是否有这个网址的映射关系，如果有，就返回IP，完成域名解析。看到这里大家应该都猜到了，有DNS的地方，就有缓存。浏览器、操作系统、本地DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。
3. 如果还没有，我的电脑就要向**本地DNS服务器**发起请求查询[www.baidu.com](http://www.baidu.com/)这个域名。
4. 本地DNS服务器拿到请求后，先检查一下自己的缓存中有没有这个地址，有的话直接返回。这个时候拿到的IP地址，会被标记为非权威服务器的应答
5. 如果本地DNS服务器的缓存中没有的话，本地DNS服务器会从配置文件中读取13个**根DNS服务器**的地址，然后向其中一台发起请求
6. 根DNS服务器拿到请求后，知道他是com.这个顶级域名下的，所以会**返回com域名中的NS记录**（用来表明哪台服务器对该域名进行解析），其实就是一个IP（com对应的服务器IP）
7. 本地DNS服务器根据返回的IP（com DNS服务器）发起请求，**com DNS服务**器发现你这请求的是baidu.com这个域，查到这个**域的NS记录**，然后返回IP（baidu.com）
8. 本地DNS服务器在根据IP（baidu.com DNS服务器）访问这些**权威服务器**，baidu.com服务器在A记录（正向解析记录，域名到IP地址的映射）中查找到www.baidu.com的IP地址，返回IP（[www.baidu.com](http://www.baidu.com/)）
9. 最终本地DNS服务器拿到用户想访问的[www.baidu.com](http://www.baidu.com/)的IP，返回给客户端，并进行缓存操作，以便下次使用。

在整个DNS解析过程中会存在递归查询过程和迭代查询过程。电脑向本地DNS服务器的查询一般都是采用递归查询，本地DNS服务器向其他DNS服务器的查询是迭代查询



## 记录类型

| 记录类型 | 描述                                         |
| -------- | -------------------------------------------- |
| SOA      | 域权威记录，说明本机服务器为该域的管理服务器 |
| NS       | 域名服务器记录                               |
| A        | 正向解析记录，域名到IP的映射                 |
| PTR      | 反向解析记录，IP到域名的映射                 |
| CNAME    | 别名记录，为主机添加别名                     |
| MX       | 邮件记录，指定域内的邮件服务器               |

一般解析过程中遇到CNAME，查询会终止，重新向根DNS服务器发起查询别名的请求



## DNS劫持

攻击者劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致用户对该域名地址进行访问的时候，由原来的IP地址转入到修改后的IP地址。结果就是让正确的网址不能解析或者是被解析到另一个网址的IP，实现获取用户资料或者破坏原有网址正常服务的目的。

由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的DNS服务器能够返回正常的IP地址，或者修改DNS以及直接IP访问。

一般而言，用户上网的DNS服务器都是运营商分配的，所以在这个节点上，运营商可以做一些事情，比如，你去访问[www.a.com](http://www.a.com/)，正常DNS应该返回10.0.0.1，而运营商劫持后，会返回一个运营商的中间服务器IP，访问该服务器会一致性的返回302（暂时重定向），让用户浏览器跳转到预处理好的带广告的网页，在该网页中再通过iframe打开用户原先访问的地址。



## DNS污染（中间人攻击）

又称域名服务器缓存投毒（DNS cache poisoning），它和DNS劫持的不同之处，在于污染针对的是DNS缓存，是在查询信息到达目标DNS服务器前，经过的节点上做手脚，而劫持是DNS服务器中记录的是错误的内容。

举例：对于GFW来说，DNS劫持用于国内服务器，因为可以修改服务器中的DNS记录，而对于国外服务器GFW无法更改其内容，故采用DNS污染的方式篡改用户收到的信息。其中的过程是，当你向国外DNS服务器查询DNS记录时，这些流量走到国际出口带宽的时候会遇到GFW的关键字审查，如果上了黑名单，GFW会立即向你返回一个虚假的DNS记录。因为DNS走的是UDP协议，加上DNS查询结果只认最快返回的，所以一定是先收到了GFW给你返回的虚假DNS记录，就算马上你收到了真正的来自国外DNS的回复，也会被你的系统无视掉。这种攻击也被称为中间人攻击。



# TCP协议

## TCP 三次握手和四次挥手

### 三次握手

- 客户端–发送带有 SYN 标志的数据包–服务端（一次握手）
- 服务端–发送带有 SYN/ACK 标志的数据包–客户端（二次握手）
- 客户端–发送带有带有 ACK 标志的数据包–服务端（三次握手）

### 为什么要三次握手

**三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

### 为什么要传回 SYN

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

> SYN (Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK（Acknowledgement [汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。

### 传了 SYN，为啥还要传 ACK

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。

### 为什么四次挥手

断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个FIN给客户端
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。



## TCP与UDP协议的区别

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。



## TCP 协议如何保证可靠传输

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### ARQ协议

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。

#### 停止等待ARQ协议

- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；

**优点：** 简单

**缺点：** 信道利用率低，等待时间长

**1) 无差错情况:**

发送方发送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送。

**2) 出现差错情况（超时重传）:**

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。

**3) 确认丢失和确认迟到**

- **确认丢失** ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。
- **确认迟到** ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。

#### 连续ARQ协议

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。

**缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

### 滑动窗口和流量控制

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 拥塞控制

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.
- **快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认接收端指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。



## TIME_WAIT状态的作用

当 TCP 连接主动关闭时，都会经过 TIME_WAIT 状态：TCP 四次挥手结束后，连接双方都不再交换消息，但主动关闭的一方保持这个连接在一段时间内不可用。

场景：四次挥手中，A 发 FIN， B 响应 ACK，B 再发 FIN，A 响应 ACK 实现连接的关闭。而如果 A 响应的 ACK 包丢失，B 会以为 A 没有收到自己的关闭请求，然后会重试向 A 再发 FIN 包。如果没有 TIME_WAIT 状态，A 不再保存这个连接的信息，收到一个不存在的连接的包，A 会响应 RST 包，导致 B 端异常响应。

1. **可靠地实现TCP全双工连接的终止**

   保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

2. **允许老的报文在网络中消逝**

   防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。



## TIME_WAIT的问题

### 客户端

如果是客户端发起了连接，传输完数据然后主动关闭了连接，这时这个连接在客户端就会处于TIMEWAIT状态，同时占用了一个本地端口。如果客户端使用短连接请求服务端的资源或者服务，客户端上将有大量的连接处于TIMEWAIT状态，占用大量的本地端口。最坏的情况就是，本地端口都被用光了，这时将无法再建立新的连接。

针对这种情况，对应的解决办法有2个：

1. 使用长连接，如果是http，可以使用keepalive
2. 增加本地端口可用的范围，比如Linux中调整内核参数：net.ipv4.ip_local_port_range

### 服务端

对于服务器而已，由于服务器是被动等待客户端建立连接的，因此即使服务器端有很多TIME_WAIT状态的连接，也不存在本地端口耗尽的问题。大量的TIME_WAIT的连接会导致如下问题：

1. 内存占用：因为每一个TCP连接都会有占用一些内存。
2. 在某些Linux版本上可能导致性能问题，因为数据包到达服务器的时候，内核需要知道数据包是属于哪个TCP连接的，在某些Linux版本上可能会遍历所有的TCP连接，所以大量TIME_WAIT的连接将导致性能问题。不过，现在的内核都对此进行了优化(待确认)。



## tcp建立连接的两端, 有一端断开连接另一端能知道吗

可以通过心跳包

或者根据服务器收到的数据的长度来判断，如果服务器收到的数据长度是0，那么意味着你的客户端程序已经断开了连接。



# HTTP协议

HTTP协议通常承载于TCP协议之上（应用层），有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。默认HTTP的端口号为80，HTTPS的端口号为443。

HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。



## HTTP Request

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

**请求行**、**请求头部**、**空行**和**请求数据**四个部分组成。

```http
GET /asdkh.jpg HTTP/1.1
Host: xxx.com
Accept: */*
Referer: http://xxx.com
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cache-Control: max-age=0
Cookie: xxxxxx
DNT: 1
Date: Mon, 31 Dec 2001 04:25:57 GMT
Connection: Keep-Alive
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36

Data
```

**第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本**

GET说明请求类型为GET,[/asdkh.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。

**第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息**

1. Host

   Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。

2. Referer

   Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。如果指定的是部分uri地址，则此地址应该是一个相对地址。

3. User-Agent

   服务器端和客户端脚本都能访问它，它是浏览器类型检测逻辑的重要基础，该信息由你的浏览器来定义，并且在每个请求中自动发送

4. Cache-Control

   Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。

5. Date

   Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如Date:Mon,31Dec200104:25:57GMT，Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。

**第三部分：空行，请求头部后面的空行是必须的**

即使第四部分的请求数据为空，也必须有空行。

**第四部分：请求数据也叫主体，可以添加任意的其他数据。**



## HTTP Response

一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。

HTTP响应也由四个部分组成，分别是：**状态行**、**消息报头**、**空行**和**响应正文**。

```http
HTTP/1.1 200 OK
ETag: W/"158-1192590101000"
Last-Modified: Wed, 17 Oct 2007 03:01:41 GMT
Date: Mon, 31 Dec 2001 04:25:57 GMT
Content-Type: text/html;charset=ISO-8859-1
Content-Length: 122
Server: Apache-Coyote/1.1

<html>
	<head>123</head>
	<body>
		<h1>asd</h1>
	</body>
</html>
```

**第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。**

第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）

**第二部分：消息报头，用来说明客户端要使用的一些附加信息**

第二行和第三行和第四行为消息报头，

**第三部分：空行，消息报头后面的空行是必须的**

**第四部分：响应正文，服务器返回给客户端的文本信息。**

空行后面的html部分为响应正文。



## HTTP状态码

| 状态码 | 类别         | 释义                       |
| ------ | ------------ | -------------------------- |
| 1XX    | Information  | 接收的请求正在处理         |
| 2XX    | Success      | 请求正常处理完毕           |
| 3XX    | Redirection  | 需要进行附加操作以完成请求 |
| 4XX    | Client Error | 客户端无法处理请求         |
| 5XX    | Server Error | 服务器处理请求出错         |



##  HTTP请求有哪些方式

| 方式    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 请求指定的页面信息，并返回实体主体                           |
| HEAD    | 类似GET，只不过不返回具体内容，用于获取报头                  |
| POST    | 向指定资源提交数据进行处理请求（例如表单、上传文件），数据被包含在请求体中，该指令可能会导致新的资源的建立和/或已有资源的修改 |
| PUT     | 从客户端向服务器传输数据以取代指定文档的内容                 |
| DELETE  | 请求服务器删除指定页面                                       |
| CONNECT | 预留给能够将连接改为管道方式的代理服务器                     |
| OPTIONS | 允许客户端查看服务器性能                                     |
| TRACE   | 回显服务器收到的请求，主要用于测试或诊断                     |



## GET/POST区别

GET在浏览器回退时是无害的，而POST会再次提交请求。 

GET产生的URL地址可以被Bookmark，而POST不可以。 

GET请求会被浏览器主动cache，而POST不会，除非手动设置。

GET请求只能进行URL编码，而POST支持多种编码方式。

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

GET请求在URL中传送的参数是有长度限制的（1024k字节），而POST没有。

对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

GET参数通过URL传递，POST放在Request body中。

>get拼接url，post传body
>
>请求缓存：GET会被缓存，而post不会 
>原因就是get是url的请求，没有请求体
>
>保留浏览器历史记录：GET可以，而POST不能 
>原因还是因为get的url请求
>
>用处：get常用于取回数据，post用于提交数据 
>原因是get的url传输不管怎么说，都是有字符数限制的，当然如果字符串长度不超，一样能提交数据
>
>安全性：post比get安全 
>因为post是请求体，不会在url上被劫持
>
>请求参数：querystring 是url的一部分get、post都可以带上。 get的querystring（仅支持urlencode编码），post的参数是放在body（支持多种编码） 
>
>请求参数长度限制：get请求长度最多1024kb，post对请求数据没有限制



## 各种协议与HTTP协议之间的关系

HTTP→TCP→IP→TCP→HTTP

1. HTTP：生成针对目标web服务器的HTTP请求报文
2. TCP：将HTTP请求报文分割成段
3. IP：搜索目标地址，边中转边传送
4. TCP：接受报文段
5. HTTP：对向web服务器请求的内容的处理



## HTTP长连接，短连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**



## HTTP是不保存状态的协议，如何保存用户状态?

HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，**Session 的主要作用就是通过服务端记录用户的状态。**典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

**Cookie 被禁用怎么办?**

最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。



## Cookie的作用是什么?和Session有什么区别？

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息**，比如：

1. 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了
2. 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)
3. 登录一次网站后访问网站其他页面不需要重新登录。

**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。



## 如何使用Session进行身份验证

很多时候我们都是通过 SessionID 来实现特定的用户，SessionID 一般会选择存放在 Redis 中。

举个例子：用户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证方式更详细的过程如下：

1. 用户向服务器发送用户名和密码用于登陆系统。
2. 服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储起来。
3. 服务器向用户返回一个 SessionID，写入用户的 Cookie。
4. 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。
5. 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。

使用 Session 的时候需要注意下面几个点：

1. 依赖Session的关键业务一定要确保客户端开启了Cookie。
2. 注意Session的过期时间



## 如果没有Cookie的话Session还能用吗？

一般是通过 Cookie 来保存 SessionID ，假如你使用了 Cookie 保存 SessionID的方案的话， 如果客户端禁用了Cookie，那么Session就无法正常工作。

但是，并不是没有 Cookie 之后就不能用 Session 了，比如你可以将SessionID放在请求的 url 里面`https://javaguide.cn/?session_id=xxx` 。这种方案的话可行，但是安全性和用户体验感降低。当然，你也可以对 SessionID 进行一次加密之后再传入后端。



## 什么是 Token?什么是 JWT?如何基于Token进行身份验证？

我们知道 Session 信息需要保存一份在服务器端。这种方式会带来一些麻烦，比如需要我们保证保存 Session 信息服务器的可用性、不适合移动端（依赖Cookie）等等。

有没有一种不需要自己存放 Session 信息就能实现身份验证的方式呢？使用 Token 即可！JWT （JSON Web Token） 就是这种方式的实现，通过这种方式服务器端就不需要保存 Session 数据了，只用在客户端保存服务端返回给客户的 Token 就可以了，扩展性得到提升。

**JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。**

JWT 由 3 部分构成:

1. Header：描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。
2. Payload（负载）：用来存放实际需要传递的数据
3. Signature（签名）：服务器通过`Payload`、`Header`和一个密钥(`secret`)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。

在基于 Token 进行身份验证的的应用程序中，服务器通过`Payload`、`Header`和一个密钥(`secret`)创建令牌（`Token`）并将 `Token` 发送给客户端，客户端将 `Token` 保存在 Cookie 或者 LocalStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：` Authorization: Bearer Token`。

1. 用户向服务器发送用户名和密码用于登陆系统。
2. 身份验证服务响应并返回了签名的 JWT，上面包含了用户是谁的内容。
3. 用户以后每次向后端发请求都在Header中带上 JWT。
4. 服务端检查 JWT 并从中获取用户相关信息。



## 为什么Cookie 无法防止CSRF攻击，而token可以？

**CSRF（Cross Site Request Forgery）**一般被翻译为 **跨站请求伪造** 。那么什么是 **跨站请求伪造** 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子：

小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求，也就是通过你的 Cookie 向银行发出请求。

```
<a src=http://www.mybank.com/Transfer?bankId=11&money=10000>科学理财，年盈利率过万</>
```

上面也提到过，进行Session 认证的时候，我们一般使用 Cookie 来存储 SessionId，当我们登陆后后端生成一个SessionId放在Cookie中返回给客户端，服务端通过Redis或者其他存储工具记录保存着这个SessionId，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个人。如果别人通过 cookie拿到了 SessionId 后就可以代替你的身份访问系统了。

Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。

但是，我们使用 token 的话就不会存在这个问题，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token，这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。

需要注意的是不论是 Cookie 还是 token 都无法避免跨站脚本攻击（Cross Site Scripting）XSS。

> 跨站脚本攻击（Cross Site Scripting）缩写为 CSS 但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为XSS。

XSS中攻击者会用各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本盗用信息比如cookie。



## HTTP 1.0和HTTP 1.1的主要区别是什么?

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **长连接** : **在HTTP/1.0中，默认使用的是短连接**，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。**HTTP 1.1起，默认使用长连接** ,默认开启Connection： keep-alive。 **HTTP/1.1的持续连接有非流水线方式和流水线方式** 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。
2. **错误状态响应码** :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
3. **缓存处理** :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
4. **带宽优化及网络连接的使用** :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。



## HTTP2.0的改进

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。



## URI和URL的区别是什么?

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。



## HTTP 和 HTTPS 的区别？

1. **端口** ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。
2. **安全性和资源消耗：**HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 又运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。
   - 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
   - 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。



## HTTPS中的TLS

### SSL 与 TLS

SSL：（Secure Socket Layer） 安全套接层，于 1994 年由网景公司设计，并于 1995 年发布了 3.0 版本
TLS：（Transport Layer Security）传输层安全性协议，是 IETF 在 SSL3.0 的基础上设计的协议，位于 HTTP 和 TCP 之间（会话层），其内部有 TLS握手协议、TLS记录协议

### TLS工作流程

**通俗说：**

1. 客户端向服务端请求HTTPS连接，服务端返回证书、公钥，客户端验证证书
2. 客户端产生随机（对称）秘钥
3. 客户端使用公钥对对称秘钥加密
4. 客户端发送加密后的对称秘钥给服务端，服务端验证
5. 客户端通过对称秘钥加密明文后发送，服务器解密读取

**详细说：**

1. Hello阶段：
   - Client发送随机数A及加密套件
   - Server发送随机数B及加密套件、服务端证书
   - Client向颁发证书的服务器验证Server证书
2. 握手：
   - Client根据证书加密随机数C为C1并发送
   - Client根据A、B、C计算出协商秘钥D及加密算法E并发送
   - Client根据D、E将之前所有通信参数hash值生成密文F并发送
   - Server根据证书秘钥解密C1得到C，根据A、B、C计算出协商秘钥D及加密算法E，根据D、E将之前所有通信参数hash值生成密文F1，与收到的F对比，发送D与E
   - Server根据D、E将之前所有通信参数hash值生成密文F2并发送
   - Client根据D、E解密F2并与F对比，握手完成

### TLS使用的密码技术

1. **伪随机数生成器**

   为什么叫伪随机数，因为没有真正意义上的随机数，具体可以参考 Random/TheadLocalRandom
   它的主要作用在于生成对称密码的秘钥、用于公钥密码生成秘钥对

2. **消息认证码**

   消息认证码主要用于验证消息的完整性与消息的认证，其中消息的认证指“消息来自正确的发送者

3. **数字签名**

   消息认证码的缺点在于**无法防止否认**，因为共享秘钥被 client、server 两端拥有，server 可以伪造 client 发送给自己的消息（自己给自己发送消息），为了解决这个问题，我们需要它们有各自的秘钥不被第二个知晓（这样也解决了共享秘钥的配送问题）

   使用自己的私钥对自己所认可的消息生成一个该消息专属的签名，这就是数字签名，表明我承认该消息来自自己
   注意：**私钥用于加签，公钥用于解签，每个人都可以解签，查看消息的归属人**

4. **公钥密码**

   公钥密码也叫非对称密码，由公钥和私钥组成，它是最开始是为了解决秘钥的配送传输安全问题，即，我们不配送私钥，只配送公钥，私钥由本人保管
   它与数字签名相反，公钥密码的私钥用于解密、公钥用于加密，每个人都可以用别人的公钥加密，但只有对应的私钥才能解开密文
   client：明文 + 公钥 = 密文
   server：密文 + 私钥 = 明文
   注意：**公钥用于加密，私钥用于解密，只有私钥的归属者，才能查看消息的真正内容**

5. **证书**

   全称公钥证书（Public-Key Certificate, PKC）,里面保存着归属者的基本信息，以及证书过期时间、归属者的公钥，并由认证机构（Certification Authority, **CA**）施加数字签名，表明某个认证机构认定该公钥的确属于此人

**总结**

| 码         | 作用                               | 组成                      |
| ---------- | ---------------------------------- | ------------------------- |
| 消息认证码 | 确认消息的完整、并对消息的来源认证 | 共享秘钥+消息的散列值     |
| 数字签名   | 对消息的散列值签名                 | 公钥+私钥+消息的散列值    |
| 公钥密码   | 解决秘钥的配送问题                 | 公钥+私钥+消息            |
| 证书       | 解决公钥的归属问题                 | 公钥密码中的公钥+数字签名 |



## 断点续传

要实现断点续传的功能，通常都需要客户端记录下当前的下载进度，并在需要续传的时候通知服务端本次需要下载的内容片段。

HTTP1.1协议（RFC2616）中定义了断点续传相关的HTTP头`Range`和`Content-Range`字段，一个最简单的断点续传实现大概如下：

1. 客户端下载一个1024K的文件，已经下载了其中512K

2. 网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：

   Range:bytes=512000-

   这个头通知服务端从文件的512K位置开始传输文件

3. 服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：

   Content-Range:bytes 512000-/1024000

   并且此时服务端返回的HTTP状态码应该是206，而不是200。



## HTTP Cache

当资源第一次被访问的时候，http返回200的状态码，并在头部携带上当前资源的一些描述信息，如

```http
HTTP/1.1 200 OK
Date:            Thu, 26 Nov 2009 13:50:54 GMT
Server:          Apache/2.2.11 (Unix)PHP/5.2.9
Last-Modified:   Thu, 26 Nov 2009 13:50:19 GMT
Etag:            "8fb8b-14-4794674acdcc0"
Accept-Ranges:   bytes
Content-Length:  20
Keep-Alive:      timeout=5, max=100
Connection:      Keep-Alive
Content-Type:    text/html
```

其中

Last-Modified   // 指示最后修改的时间
Etag           // 指示资源的状态唯一标识
Expires        // 指示资源在浏览器缓存中的过期时间

接着浏览器会将文件缓存到Cache目录下，并同时保存文件的上述信息

当第二次请求该文件时，浏览器会先检查Cache目录下是否含有该文件，如果有，并且还没到Expires设置的时间，即文件还没有过期，那么此时浏览器将直接从Cache目录中读取文件，而不再发送请求

如果文件此时已经过期，则浏览器会发送一次HTTP请求到WebServer，并在头部携带上当前文件的如下信息

```http
If-Modified-Since: Thu, 26 Nov 2009 13:50:19 GMT
If-None-Match:    "8fb8b-14-4794674acdcc0"
```

即：把上一次修改的时间，以及上一次请求返回的Etag值一起发送给服务器。服务器在接收到这个请求的时候，先解析Header里头的信息，然后校验该头部信 息。 如果该文件从上次时间到现在都没有过修改或者Etag信息没有变化，则服务端将直接返回一个304的状态，而不再返回文件资源，状态头部如下

```http
HTTP/1.1 304 Not Modified
Date:        Thu, 26 Nov 200914:09:07 GMT
Server:      Apache/2.2.11 (Unix)PHP/5.2.9
Connection:  Keep-Alive
Keep-Alive:  timeout=5, max=100
Etag:        "8fb8b-14-4794674acdcc0"
```

这样，就能够很大程度上减少网络带宽以及提升用户的浏览器体验。 当然，如果服务器经过匹配发现文件修改过了，就会将文件资源返回，并带上新文件状态信息。

**Etag / If-None-Match**

一对验证文件实体的标记 "Entity Tag:的响应/请求头.

Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的

**Last-Modified / If-Modified-Since**

一对验证文件的修改时间的响应/请求头

Expires、 Cache-Control、Last-Modified、ETag是RFC2616（HTTP/1.1）协议中和网页缓存相关的几个字段。 前两个用来控制缓存的失效日期，浏览器可通过它来判定，需不需要发出HTTP请求； 后两个用来验证网页的有效性，服务器端利用它来验证这个文件是否需要重新返回

**Last-Modified V.S. Etag**

既然有了Last-Modified，为什么还要用ETag字段呢？因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确。因此，HTTP/1.1利用Entity Tag头提供了更加严格的验证。
